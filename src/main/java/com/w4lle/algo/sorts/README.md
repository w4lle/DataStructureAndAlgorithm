# 排序

# 如何分析一个排序算法

1 算法执行效率

- 最好、最坏、平均 时间复杂度
- 时间复杂度的系数、常数 、低阶
- 比较次数和交换（或移动）次数

2. 算法的内存消耗，即空间复杂度

3. 稳定性

如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

![](https://ws2.sinaimg.cn/large/006tNbRwly1fxoy1k6kdhj31780nm42m.jpg)

![](https://ws1.sinaimg.cn/large/006tNbRwly1fxyaah1n4oj311e0midjl.jpg)

O(nlogn) 的排序算法还有堆排序，原地、非稳定排序算法，实现原理是，先建堆（堆化） O(n) 、再排序 O(nlogn)。
由于堆是完全二叉树，且大顶堆的每个节点都比子节点大，所以建堆的过程可以用从上到下的方法堆化 0-n/2 的数据(n/2+1 -n 都是子节点)
但是性能没有快速好，1是因为局部区域访问不连续，对cpu缓存不友好，2是因为交换次数较多
具体见： [堆排序](https://time.geekbang.org/column/article/69913)

除此之外，还有中序遍历的二叉查找树，时间复杂度 O(n)
二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
所以中序遍历后就是有序的。